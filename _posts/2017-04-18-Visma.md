---
layout: post
title:  "Caap with VISMA IT"
author: "Pedro Dias"
author-link: "http://twitter.com/digitaldias"
date:   2017-04-18
categories: [Conversations as a Platform]
color: "blue"
excerpt: Microsoft worked with VISMA to create a first-line support bot to ease the pressure on the support team
language: English
verticals: [Public Sector]
---

![VISMA Logo](../images/VISMA-IT/visma-logo.jpg)

### Solution Overview

*In this hackfest, Microsoft and VISMA teamed up in Microsoft's office in Lisbon to create a support bot based on the **Microsoft Bot Framework***.


The hackfest was organized by Microsoft. Specialists on Conversation as a Platform (CaaP) were flown in to Lisbon to assist the companies realize their goals. 
Each company had their own mentor from Microsoft assisting in writing the code and helping pass the know-how to the participants. 

The aim of this hackfest was to deliver a working *proof of concept* (POC) of the bot, so that VISMA could finalize the product with the know-how to do so. 
The solution builds on the Microsoft Bot Framework, it utilizes [QnAMaker](https://www.microsoft.com/cognitive-services/en-us/qnamaker), and then extends the functinality of the bot to ask follow-up questions, and pass the conversation over to a human when required.
As the bot is meant to operate in Swedish, we also made good use of the [Translator API](https://www.microsoft.com/cognitive-services/en-us/translator-api) in order to be efficient.

This document provides you with technical insight into the solution and gives you a means to get started on doing something similar on your own. 
It focuses on a few key areas of the that were particularly challenging.

![Hackfest in progress](../images/VISMA-IT/hackfest.jpg)<br />
**Image:** *This hackfest was part of a larger hackfest around CaaP that involved companies from all over Europe*



### Key Technologies used 
In this hackfest, the following technologies were adressed. 
Follow the links to read more about each individual technology:

- [Microsoft Bot Framework](https://dev.botframework.com/)
  - [Understanding the Bot Connector](https://docs.botframework.com/en-us/csharp/builder/sdkreference/connector.html)
  - [FormFlow](https://docs.botframework.com/en-us/csharp/builder/sdkreference/forms.html)
  - [QnAMaker](https://www.microsoft.com/cognitive-services/en-us/qnamaker)
- [Language Understanding Intelligent Service (LUIS)](https://www.luis.ai/)  
  - [LuisDialogs](https://docs.botframework.com/en-us/node/builder/chat-reference/classes/_botbuilder_d_.luisdialog)
- [Microsoft Translator API](https://www.microsoft.com/cognitive-services/en-us/translator-api)
- [Microsoft Azure](https://azure.microsoft.com/en-us/)
    - [Web Apps](https://azure.microsoft.com/en-us/services/app-service/web/) 
- [The C# Language](https://msdn.microsoft.com/en-us/library/aa287558(v=vs.71).aspx)
- [Visual Studio Team Services](https://www.visualstudio.com/team-services/)
  - [Work Item Management in Agile Tools](https://www.visualstudio.com/team-services/agile-tools/)
  - [Source Control with Git](https://www.visualstudio.com/team-services/git/)
  - [Continous Integration](https://www.visualstudio.com/team-services/continuous-integration/)
  - [Continous Deployment using Release Management](https://www.visualstudio.com/team-services/release-management/)

### Core Team


| Company          | Person                | Role                          | Twitter Handle |
| -------          | ----                  | ----                          | -------------- |
| Microsoft        | Pedro Dias            | Technical evangelist / Mentor | @digitaldias   |
| VISMA Consulting | Terje Hoås            | Lead Developer                |                |
| VISMA SPCS       | Johan Nicklasson      | Designer / Conversationalist  |                |

![People hacking](../images/VISMA-IT/people.jpg)<br />
**Image:** *Active hackfest Lisbon's Microsoft office*

## Customer profile


>**VISMA SPCS**<br />
>[WebSite](https://vismaspcs.se)<br />

VISMA provides solutions and hosting services to more than 500 000 customers, and employ over 5 500 people across several countries.
Today, more than half of Sweden's small businesses use software from VISMA.

Being the leading Nordic provider of hosting solutions, VISMA provides their communities with tools and frameworks to promote innovation in 
their software businesses. 

The revenue in 2015 was more than $1 000 million.

[**VISMA SPCS**](https://vismaspcs.se/) is the part of VISMA responsible for their offer containing invoicing and book keeping. 
Their main customers are small and medium sized companies, not necessarily with CFO’s in their organization. 

## Problem statement

VISMA currently employs a staff of 130 people dealing with customer support for their products. They process around 480 000 support cases / year, 43% of which 
are handled in chat sessions, the other channels include email and phone as well as support forums. They serve around 2 000 daily visitors to their support website.

They are looking for ways to offload the support agents by introducing a smart chatbot, that can take the simpler questions, as well as provide faster responses to their customers.
Response time is important, and they are looking for a service that is future proof, with the possibility to be expanded in the future. 

For customer experience, the service needs to deliver an SLA of 99,9% in according to the company standard and be easy to maintain. 
In addition they want to support Swedish language. 

Initially, VISMA is considering a web-channel for their support, but want to explore the other channles in the Bot Framework further down the line. 
An architecture diagram is attached below (in this document). 


>"I think that one of the challenges of giving support in the future will be the expectation of availability 24 hours a day. 
>To solve that in a smart way I believe we need to explore and try new technology as a complement to our support offer today.”<br />
>**Eric Raab-Obermayr**<br />
>*Customer Success Manager*<br/>
> Visma Spcs.

## Solution and Steps

VISMA has kept a copy of every chatlog so they can learn and improve on how they deliver customer support. 
This chatlog consisted of around 73 000 dialogs (at the time of the hackfest), containing largely unstructured conversations. 
We had some hopes of being able to use the chatlog during out bot development, however the data was so unstructured that we ended up with the following plan: 

- Read and group each support chat into topics (done in NotePad)
- Examine each category to extract intents within each (also NotePad)

The result of this work landed in the following topics for the bot


| Topic         | Subtopics | 
| -----         | --------- |
| Sales         | Quotes, Sales Invoices, Sales Orders, Customers, Articles             | 
| AutoInvoicing |                                                                       | 
| Purchasing    | Purchase invoices, Suppliers, Source Document images                  | 
| Payroll       | Payslips, Employees, Tax Reporting                                    |
| Cash and Bank |                                                                       | 
| Accounting    | Journalling, Analysis, VAT, Assets, Cost Centres, Projects, Reporting |  
| Settings      | Company Settings, Financial Years, Account Charts, Import & Export    | 
| Other         | Signing in, Integrations, Add-ons, Other applications                 |


In total, 28 distinct topics were identified, each with a variety of questions to be answered by the bot.
From these, we identified over 120 distinct intents that we could have our bot respond to. There are more, many more, but we decided to 
learn as much as possible about the Bot Framework, and leave some of the intents to implement *after* the hackfest. 

During the hackfest we established a pattern of work for dealing with all the identified topics in a way that 
will have a great impact on the number of chats with humans. We believe we've found a working solution that also
manages the limitations of LUIS (no swedish), and a good strategy for handing over questions from the QnA Maker to our own
intelligence. 


## Technical Delivery

There are three main apps in the solution:
<dl>
	<dt>SupportBot</dt>
	<dd>The bot service code, which contains the bot code. Essencially a WebApp that provides the entry point to the bot framework</dd>
	<dt>SupportBot.ToEnglishTranslator</dt>
	<dd>A console-application that can translate swedish textfiles and produce english output files</dd>
	<dt>(Undisclosed)</dt>
	<dd>A test-client application for developing the connection to the human chat service</dd>
</dl>

### Architecture

#### Service Tiers in the solution

The services, or main actors involved in the solution are: 
![Services Diagram](../images/VISMA-IT/connectedServices.png)

| Service                | Usage | 
| -------------          | ----- |
| Bot Connector          | Provides an endpoint for the users to connect with the bot             |
| Bot Framework Channels | The avilable chat channels that the bot framework supports             | 
| VISMA Bot Web service  | The web application where the Bot code is running                      | 
| LUIS                   | Language Intelligent Understanding Service                             |
| Translate API          | For translating text from Swedish to English                           |
| QnAMaker               | Automatically created bot from frequently answered questions documents | 
| Chat Service           | Service to pass the conversation over to a human                       |



#### Architecture choice
The solution we built was inspired by the [DDD N-Layered](https://blogs.msdn.microsoft.com/cesardelatorre/2010/03/25/our-brand-new-ddd-n-layered-net-4-0-architecture-guide-book-and-sample-app-in-codeplex/) architecture form. 
In essence, this architecture type is built  up by defining a set of Domain Entities and the Contracts that impact them. It lends itself very well to the [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)) 
principles of Object-Oriented design, and makes Unit-Testing a breeze. Explaining N-Layered DDD or SOLID is beyond the scope of this document, however, the following 
screenshot shows how the different layers of the solution makes the code easy to maintain over time: <br />
![Visual Studio Solution](../images/VISMA-IT/supportBotSolution.png)

We opted to use [Structuremap](http://structuremap.github.io/) as our IoC Container, and [xUnit](https://xunit.github.io/) as our unit-testing framework.


### Setting up Visual Studio Team Services

#### Agile
Every projects needs management, and the hackfest was no exception. A place for source control, agile tools to handle tasks, and a CI/CD pipeline. Luckily, 
VSTS provided all of these, and on day one, we set up our ambitions in a storyboard, detailed each story with tasks, and created 
a sprint iteration for the hackfest week.
![Storyboard](../images/VISMA-IT/storyboard.png)

#### Continous Integration
Upon every push from Visual Studio, we trigger a build to ensure that the code still works and that there aren't any "magic machine" symptoms. 
The build report gives a very nice overview, not only of the success of the build, but also which tasks are referenced in the build and the code 
changes that it adresses. Seeing the results of the Unit-tests is also nice
![Build Report](../images/VISMA-IT/buildReport.png)

#### Continous Delivery

After a successful build, VSTS will deploy the code into the Production environment, so the bot can be tested both internally and by selected people.
![Release Report](../images/VISMA-IT/releaseReport.png)

Being able to see the associated tasks on the release reports makes it easier for testers to know where to put their test efforts. Also, making
sure that our development environment is updated on every commit ensures that the non-technical stakeholders in the solution can test the latest
additions to the solution. Seeing the release reports from build and release processes also helps them understand what was added to the solution.


                                     |

### Setting up the bot

All bots need to be defined in the [Microsoft Bot Directory](https://bots.botframework.com/) in order to be available to the outside world. 
The directory is responsible for setting up the necessary channels between your client and your Web App. 

Begin by heading over to the [Azure Portal](https://portal.azure.com) and create a new Bot Service. You do this
by clicking on the "new" button, search for "bot" and you'll find the Bot Service ready to be created. This essencially creates an Azure App Service
![Create a new Bot Service in Azure Portal](../images/VISMA-IT/azure_initial_creation.jpg). 

Once created, you'll need to create a Microsoft APP ID. This is the same process as for creating apps in Facebook, Twitter and Google: <br />
![AppId creation](../images/VISMA-IT/generateAppId.png)

Next, head over to [dev.botframework.com](http://dev.botframework.com) to create the bot profile. You provide the URL of your app service here to connect the Bot Profile to your
bot service: 
![Create Bot Profile](../images/VISMA-IT/createBotProfile.png)

>**NOTE**<br />
>You do not need to create an extra AppID/Password here. Just pass in the values from the Azure Portal AppID Registration.

Done. You now should have a Bot Service in Azure, as well as a registration for your bot that you can access in the channels of your choice. 


### Working with Dialogs, LuisDialogs and QnAMaker Dialogs

The way to implement the Bot Framework in C# is creating a web app with a single **MessagesController** that acts as the entry point for all conversations. 
Instructions for getting started with this [can be found here](https://docs.botframework.com/en-us/csharp/builder/sdkreference/).

Our **MessagesController** contains a single POST method that is implemented as follows:

```csharp
public async Task<HttpResponseMessage> Post([FromBody]Activity activity)
{
    if (activity == null) return new HttpResponseMessage(HttpStatusCode.Accepted);
    var connector = new ConnectorClient(new Uri(activity.ServiceUrl));
    switch (activity.GetActivityType())
    {
        case ActivityTypes.Message:
            await Conversation.SendAsync(activity, () => new RootDialog());
            break;

        case ActivityTypes.ConversationUpdate:
        case ActivityTypes.Ping:
        case ActivityTypes.ContactRelationUpdate:
        case ActivityTypes.Typing:
        case ActivityTypes.DeleteUserData:
            break;
        default:
            Trace.TraceError($"Unknown activity type ignored: {activity.GetActivityType()}");
            break;
    }
    var response = Request.CreateResponse(HttpStatusCode.OK);
    return response;
}
```
The Bot connector will send a JSON structure of type **Activity** that contains contextual about the conversation. 
In the **Post** method of the controller, this activity is then passed onto an **IDialog** instance using a top-level **Conversation** object, that is the 
Composition root of the Bot framework. 

As you can see from the code above, the bot framework not only reacts to messages, but it also allows us to hook into other
types of events, such as a ping request, the user typing, updates to the conversation and more.

#### Dialogs

The [documentation on Bot dialogs](https://docs.botframework.com/en-us/csharp/builder/sdkreference/dialogs.html), didn't really give us a good understanding
of how the Dialogs are supposed to work, so we wanted to share what we learned from it here, to save you some time:

There is a root interface **IDialog** that is defined as '*a conversational processs that produces a type of result*'. 

For example, if you want to engage in a conversation to help the user find a particular invoice, we could declare the following **IDialog** class:

```csharp
[Serializable]
class FindInvoiceDialog : IDialog<Invoice>
{
}
```
(All IDialog classes must be marked serializable)

This class would then define a conversational process that, when ended, produces an object of type **Invoice**. 
The interface declares a single method that needs to be implemented: 

```csharp
public async Task StartAsync(IDialogContext context){}
```
The **context** object we are interested in, an **IAwaitable&lt;MessageActivity&gt;**, contains the text written by the user.
handling a message is a simple matter of passing the **context** to a method with the following signature: 

```csharp
async Task MethodName(IDialogContext context, IAwaitable<IMessageActivity> result)
```
Note that other types of activities can be handled the same way, i.e to handle a conversation update: 
```csharp
async Task MethodName(IDialogContext context, IAwaitable<IConversationUpdateActivity> result)
```


The **StartAsync()** method receives the conversational context from the **MessagesController** and then applies the necessary logic and flow to complete it's mission.
Ending a dialog is done by calling *context.Done&lt;TResult&gt;()*
```csharp
var invoice = InvoiceManager.GetInvoice(someFilter);
if(invoice != null)
	context.Done<Invoice>(invoice);
//otherwise proceed with more dialog
```

##### Multiple dialogs
It is possible to handle all conversation within a single dialog, however with the number of topics and intents in the solution, 
this would quickly become a gigantic class with hundreds of lines of code! 

The Microsoft Bot Framework allows for dialogs to pass their
context and questions to other dialogs, which makes sense seen from a management/developer perspective. Less is always more!

We decided to create one **IDialog** per topic, and then keep intents local to that dialog, thus each dialog's *StartAsync* method looks similar to this: 

```csharp
// In class 'AccountingDialog'
public async Task StartAsync(IDialogContext context)
{
    if (!_greetingDisplayed)
    {        		 
        await context.PostAsync("So, what can I help you with concerning accounting?");
        _greetingDisplayed = true;
    }
    context.Wait(ReactToLuisQuestion);
}
```

##### How the bot writes and waits for text
The way the bot writes text to the client is by using the *PostAsync()* method. You can send a simple string, or more complex structures to this method. 

The call to **context.Wait()** puts the bot in "listening mode", meaning it is waiting for the user to send a message back to it. Once received, the message
is handled in the **ReactToLuisQuestion()** method:

```csharp
private async Task ReactToLuisQuestion(IDialogContext context, IAwaitable<IMessageActivity> result)
{
    var messageActivity       = await result;
    var question              = messageActivity.Text;
    string translatedQuestion = await TranslateQuestionToEnglish(question);
    var luisResult            = await _luis.QueryAsync(translatedQuestion, CancellationToken.None);
    var topScoringIntent      = luisResult.TopScoringIntent;

    // LUIS is not sure enough about the intent, pass the question to QnAMaker
    if (topScoringIntent.Score < 0.9)
    {
        await context.Forward(new QnADialog(), DoAfterQnAMakerDialog, messageActivity, CancellationToken.None);	
    }
    else // LUIS is sure about the user's intent.
    {
        switch (topScoringIntent.Intent)
        {
            case "JournalEntryChange":
                await context.PostAsync(RespondToJournalEntryChange(context));
                await AskForMoreQuestionsAsync(context);
                break;

            case "JournalEntryCreate":
                await context.PostAsync(RespondToJournalEntryCreate(context));
                await AskForMoreQuestionsAsync(context);
                break;

            /* { Rest of cases chopped for brevity } */*
        }
    }
}
```

In the code above, *StartAsync* passes the conversation to the method *ReactToLuisQuestion()* which translates the swedish text into
english, and then submits the translated question to LUIS For intent detection. If the intent detected by LUIS has a low score (less than 90%), 
the original swedish question is passed to the QnAMaker dialog using *Context.Forward()*, otherwise, the intent is handled by the AccountingDialog.

Some learnings made from the code snippet above:

>**OBSERVATION 1** <br />
>We decided to use the **topScoringIntent** from LUIS, however, the *LuisResult* object does contain a list of ***all***
>the identified intents, together with their score. An alternative to passing the question over to QnAMakerDialog directly
>would be to present the user with these intents to let them choose the answer they believed to be the best match.

>**OBSERVATION 2**<br />
>**Context.Forward()** is used when you want to pass your existing message to a different dialog and instantly react to it.
>There is a similar construct named **Context.Call()** which just initiates a new dialog, but does not pass any *MessageActivity* to it. We use
>**Context.Call()** from our RootDialog after choosing the topic for the conversation.


>**OBSERVATION 3**<br />
>It helps to think of multiple dialogs as stacking dialogs on top of eachother:
>
>*RootDialog* called *AccountingDialog* which forwarded the question to *QnADialog**
>
> Once the QnADialog finishes by calling **Context.Done()** the method 
>**DoAfterQnAMakerDialog()** is called back in the *AccountingDialog* that called it and once the *AccountingDialog* calls its **context.Done()**, the 
>context of the conversation falls back into the *RootDialog*, that only knows how to present a choice of topics.






#### QnAMaker

Before arriving in Lisbon, VISMA had investigated QnAMaker to provide a starting point for the hackfest. There are a series of blog posts
pointing to a NuGet packaged name [QnAMakerDialog](https://github.com/garypretty/botframework/tree/master/QnAMakerDialog) which allows you to 
hook up the QnAMaker by providing the subscription key and knowledgebase ID as follows: 

```csharp
[Serializable]
[QnAMakerService("YOUR_SUBSCRIPTION_KEY", "YOUR_KNOWLEDGE_BASE_ID")]    
public class QnADialog : QnAMakerDialog<object>
{
    public override async Task DefaultMatchHandler(IDialogContext context, string originalQueryText, QnAMakerResult result)
    {
        await context.PostAsync(MessageCleanup(result.Answer));
        context.Wait(MessageReceived);
    }


    [QnAMakerResponseHandler(90)]
    public async Task LowScoreHandler(IDialogContext context, string originalQueryText, QnAMakerResult result)
    {
        var message  = context.MakeMessage();
        message.Text = originalQueryText;
            
        await context.Forward(new RootDialog(), RootDialogDone, message, new CancellationToken());
        context.Wait(MessageReceived);
    }


    public override async Task NoMatchHandler(IDialogContext context, string originalQueryText)
    {
        var message  = context.MakeMessage();
        message.Text = originalQueryText;
        await context.Forward(new RootDialog(), RootDialogDone, message, new CancellationToken());

        context.Wait(MessageReceived);
    }
}
``` 
The code snippet above shows how QnAMakerDialog makes the process easy. *DefaultMatchHandler()* provides the QnA response, however, 
by attributing the method *LowScoreHandler()* in the way done, we can tell QnAMaker to pass the question to a different IDialog. 
There is also a *NoMatchHAndler()* for the cases where QnAMaker didn't find a reply at all.

### Dialog sequence
Using QnAMaker is a fantastic way to convert existing QnA documents into working bots literally in minutes! The QnAMaker Bot will yield an answer along with a certainty level (between 0 and 1) of how sure it is that it found the correct answer to 
the user's question. We decided to set the bar at 90%. If the certainty of QnAMaker falls below this, we passed the question on to our own code. 

At the start of the hackfest, we already had a QnADialog made, and our first line of thought was to hand all questions to QnAMaker. The questions with a low score (less than 90%) would be translated to english, 
and then forwarded to LUIS: 
![Sequence Diagram using QnAMaker](../images/VISMA-IT/visma_sequence_luis.jpg)<br />
**Original Design**: *The users question can't be answered by the QnAMaker bot, and is translated and passed to LUIS for intent discovery*



We found that covering all 28 topics from a single QnA would be too hard to maintain and expand. With hundreds of intents, we chose instead to have our 
bot ask about the topic of the question at the very beginning of the conversation, and THEN, through code, first determine if it is an advanced question requiring 
follow-up questions - if not, choose the correct QnA to pass it to. We also chose 
to have the bot try to determine intent through LUIS *before* handing it over to QnA as many of the questions require follow-up dialogs.

The final sequence thus became: 
![Final Sequence Diagram](../images/VISMA-IT/finalFlow.png)<br />
**Final design**: *User is presented with a list of topics, chooses a topic, and asks a question. The question is translated, and passed to LUIS for intent detection. If the intent is unclear or undetermined, the original question is passed to QnAMaker*


>**OBSERVATION**<br />
>This flow is still not perfect. Ideally we would like the user to be able to post her question directly to the bot, and have the framework decide the topic of the conversation based
>on the question before choosing the correct dialog, however, due to time restrictions, we opted to present the user with a list of covered topics at the start of the conversation, and 
>look at the problem after the hackfest.




### Translation API
Because LUIS does not work with Swedish language, we learned that we had to translate the text from swedish into english in order to leverage its power. 
To get started quickly with the [Translation API](https://www.microsoft.com/cognitive-services/en-us/translator-api), we opted to clone some of Pedro's opensource work, as 
he had already created a C# client to access the api. [The original repository on GitHub ](https://github.com/digitaldias/Translate) connects to the Translate API, 
obtains a token which it refreshes internally every 9 minutes to keep the translation service alive. From our code, this is how it is used: 

```csharp
private static async Task<string> TranslateQuestionToEnglish(string questionInSwedish)
{
    var translator = WebApiApplication.Container.GetInstance<ITranslationService>();
    var swedish    = translator.SupportedLanguages["sv"];
    var english    = translator.SupportedLanguages["en"];

    var translatedQuestion = translator.TranslateSingle(swedish, english, questionInSwedish);

    return translatedQuestion;
}
```
**Code:** *In the snippet above, we're using IoC to obtain an instance of the TranslationService. We then specify that we want to translate from 
swedish to english, and then submit the original, swedish question for translation.*

>**OBSERVATION**<br />
>As you can see from the code above, we decided to hard-code swedish to english translation to keep the code simple, however, we will be placing the 
>languages within the context of the Bot Conversation, so that we later can support multiple languages. The reason for using swedish-only at the moment
>is that our answers are all in pure swedish, and translating them from english doesen't provide sufficient quality text to the end user.


### LUIS

[LUIS](http://luis.ai) is a simple, straight-forward API used to discover the *intent* of a question (named **Utterance**), for example we defined the question:<br />

&mdash; &quot;How do I create a new Journal Entry?&quot;

to correspond to a **JournalEntryCreate** intent. By providing a few examples on how to ask this question, LUIS then does 
a fantastic job of discovering the intent using phrases that aren't exact matches. In our code, we then use a simple
**switch** between the defined intents to manage the conversation.

#### T-English
Given that we brought with us a staggering amount of chat dialogs, we made a simple console application to translate the 
original swedish questions into a form of english that we could train LUIS with. 

We ended up calling it **T-English** (Translated English), and saw a few humorous translations along the way, for example:

&mdash; "Hur stryker jag en verifikation?" (Real English: how do I delete a verification?)<br />

Translates to: 

&mdash; "How do I iron a verification?" (the swedish word "stryka" can mean "to delete something" or "iron clothes")

Training LUIS with utterances in *T-English* allowed us to identify the correct intent in a near-perfect way
and gave us the correct intents after only a few lines of *T-English* utterances. LUIS uses machine-learning to observe the text, 
and doesen't really care about the meaning of the words to do its magic.

#### LuisDialog

Within the Bot Framework, there is a construct named **LuisDialog** which is meant to simplify working with LUIS. 
Instead of creating a Dialog class that expands the **IDialog** interface, one can instead inherit from a **LuisDialog** class
and connect it to the LUIS service as such: 

```csharp
[Serializable, LuisModel("{LUIS APP ID}", "{LUIS SUBSCRIPTION KEY}")]
public class AutoInvoiceDialog : LuisDialog<object>
{
    [LuisIntent("HowToCreateAutoInvoice")]
    public async Task HowToCreateAutoInvoice(IDialogContext context, LuisResult result)
    {
        await context.PostAsync("This is how you create an AutoInvoice...");
        context.Done<object>(null);
    }
}
```
This is a very clean approach that we would use if LUIS supported Swedish, however, we did not find any way for us to translate the 
text passed to LUIS and since our *RootDialog* establishes the conversational topic, and then hands the conversation 
over to the corresponding topic dialog that does translation, we simply couldn't justify creating additional *LuisDialog* 
classes to handle the discussions, so we kept our **IDialog** classes and discover Intents using the method described earlier in this document. 

#### Multiple LUIS apps
Because of our vast number of topics, we decided that one LUIS app alone wouldn't be able to serve the hundreds of intents that we wanted
to answer. LUIS "only" supports a maximum of 80 intents per application so a natural solution was to create one LUIS App for each of the topic 
dialogs. 

Currently, the pricing model for LUIS doesen't incur any base charge, only for usage, so we saw no issues in choosing this path. 

### Handing over the conversation to a human

At some point in a support conversation, the VISMA bot will have to yield. Even with the extensive log of chats, we cannot foresee
every possible question using dialogs and QnaMaker, and the user may also not feel entirely comfortable chatting with a bot, so we 
wanted to be able to pass the conversation over to a human support engineer from the bot. 
![Passing the conversation to a human](../images/VISMA-IT/passingToHuman.png)
 
Even though this document does not detail the specifics of the chat service that VISMA uses, 
we made some learnings that we believe can be good for you to know about. 

The benefit of choosing to go with one Dialog per topic proved useful when handing over the conversation to a human support engineer as well. 
Each of the topics have a limited set of people specialized in an area of the software, which meant that the dialog itself could reach out to the 
correct subject matter experts instead of randomly just calling the chat service, something that is of immediate value to VISMA.

#### Collecting user data using FormFlow
In order for the support engineer to know who he/she is talking to, we wanted the bot to ask the user for some data before reaching out: 
- What is the users name?
- Is the user a client of VISMA?
- If so, does he/she have their customerId nearby?
- IF they have the customer ID, provide it



#### Obtaining the conversational log

#### Handing the conversation over to the Support Engineer


## Conclusion

>“We made some breakthroughs during the hackfest and it will be very exciting to see the progress from now on since we’ve gained a lot of new experiences, skills and tools to continue our work”<br />
>**Eric Raab-Obermayr**<br />
>*Customer Success Manager*<br/>
> Visma Spcs.


### Measurable Impact

- Ability to answer 5-10% of the current base will save in excess of 150 000$ per year
- Having the bot service connect to the right support engineer saves a significant amount of time
- The solution architecture can easilly be expanded to include more products

### General lessons
- Current documentation is lacking
- Understanding FormFlow is an effort
- Passing a conversation over to a human is not trivial


### Opportunities going forward
- Details on how the customer plans to proceed or what more they hope to accomplish
- Using sentiment analysis to detect frustrated users, or discover upsale opportunities for happy users
- Provide users with the ability to submit screenshots 

## Additional Resources
Finding the right information when starting with a new technology is a challenge. Below is 
a link to our own repo's, as well as links that we found very useful during the hackfest:

### GitHub Repos
- [VISMA Shareable code from the project](https://github.com/#)
- [Handing over conversation to a human](https://github.com/tompaana/intermediator-bot-sample)
- [Translation API C# Wrapper](https://github.com/digitaldias/Translate)
- [QnAMakerDialog](https://github.com/garypretty/botframework/tree/master/QnAMakerDialog)

### Documentation
- [Microsoft Bot Framework Documentation](https://docs.botframework.com/)
- [Microsoft LUIS Documentation](https://www.luis.ai/home/help)
- [Microsoft QnA Maker](https://www.microsoft.com/cognitive-services/en-us/qnamaker)

### Helpful blog posts
- [The Microsoft Bot Framework blog](https://blog.botframework.com/2016/03/30/BotFramework/)
- [James Mann's YouTube series on getting started with bots using .NET](https://www.youtube.com/playlist?list=PLgF-CyaX1p3FE55OTRNH-kOb16zqeBZCo)
- [James Mann's YouTube series on getting started with bots using NODE](https://www.youtube.com/playlist?list=PLgF-CyaX1p3Exrp9F80bSIdNdnw2iTAZp)

